\chapter{Некоторые сведения о технологиях, задействованных в разработке 2D игр}
\section{Процессы и потоки в Android OS. Управление памятью приложений}

Когда запускается компонент приложения и приложение не имеет других запущенных компонентов, Android создает новый процесс для приложения с одним потоком исполнения. По умолчанию все компоненты одного приложения запускаются в одном процессе, в потоке называемом «главный». Если компонент приложения запускается и уже существует процесс для данного приложения(какой-то компонент из приложения существует), тогда компонент запущен в этом процессе и использует его поток выполнения. Вы можете изменить данное поведение, задав разные процессы для разных компонентов вашего приложения. Кроме того вы можете добавить потоки в любой процесс.

Задать отдельный процесс для компонента можно с помощью файла манифеста. Каждый тег компонента(activity, service, receiver и provider) поддерживает атрибут android:process. Данный атрибут позволяет задать процесс, в котором будет выполняться компонент. Также вы можете задать процесс в котором будут выполняться компоненты разных приложений. Также данный атрибут поддерживается тегом application, что позволяет задать определенный процесс для всех компонентов приложения.

Android пытается поддерживать процесс приложения как можно дольше, но когда потребуются ресурсы старые процессы будут вытеснены по иерархии важности.

Существует 5 уровней иерархии важности: (процессы первого уровня из списка будут удалены последними)

\begin{itemize}
\item Процесс с которым взаимодействует пользователь(Foreground process)
К таким процессам относится например: активити с которым взаимодействует пользовать; сервис(экземпляр Service), с которым взаимодействует пользователь; сервис запущенный методом startForeground(); сервис, который выполняет один из методов своего жизненного цикла; BroadcastReceiver который выполняет метод onReceive().

\item Видимый процесс
Процесс, в котором не выполнены условия из пункта №1, но который влияет на то, что пользователь видит на экране. К примеру, вызван метод onPause() активити.

\item Сервисный процесс
Служба запущенная методом startService()

\item Фоновый процесс
Процесс выполняемый в фоновом режиме, который невиден пользователю.

\item Пустой процесс

\end{itemize}

Отмечу, что в компонентах приложения существует метод onLowMemory(), но полагаться на то, что данный метод будет вызван нельзя, также как нельзя на 100% полагаться на метод onDestroy(), поэтому логику сохранения данных или каких-либо настроек можно осуществить в методе onStop(), который(как уверяют) точно вызывается.

Когда запускается приложение, система создает «главный» поток выполнения для данного приложения, который также называется UI-потоком. Этот поток очень важен, так как именно в нем происходит отрисовка виджетов(кнопочек, списков), обработка событий вашего приложения. Система не создает отдельный поток для каждого экземпляра компонента. Все компоненты, которые запущенны в одном процессе будут созданы в потоке UI. Библиотека пользовательского интерфейса Android не является потоково-безопасной, поэтому необходимо соблюдать два важных правила:

\begin{itemize}
\item Не блокировать поток UI
\item Не обращаться к компонентам пользовательского интерфейса не из UI-потока
\end{itemize}

\underline{ AsyncTask } позволяет выполнить асинхронную работу и делать обновления пользовательского интерфейса.
Для обновления реализуйте метод onPostExecute(), а всю фоновую работу заключите в метод doInBackground(). После того, как вы реализуете свою собственную задачу, необходимо ее запустить методом execute().

Параметры передаваемые в AsyncTask:
\begin{itemize}
\item Параметры
\item Прогресс(единицы задающие ход изменения задачи)
\item Результат выполнения задачи
\end{itemize}

Отмечу пару важных моментов, которые нужно учитывать:
\begin{itemize}

\item Метод doInBackGround() выполняется в фоновом потоке, потому доступа к потоку UI внутри данного метода нет.
\item Методы onPostExecute() и onProgressUpdate() выполняются в потоке UI, потому мы можем смело обращаться к нашим компонентам UI.
\end{itemize}

Android не поддерживает swap памяти. Это означает, что любые манипуляции, связанные с памятью, например, создание новых объектов, никак не влияют на выделенную память : она постоянна в RAM. Поэтому, единственно верный способ полного освобождения памяти текущего приложения - это освободить ссылки на объекты, таким образом делая память доступной сборщику мусора. 

С целью обеспечения всех своих текущих потребностей в RAM, Android старается поделить её между между процессами. Это может быть достигнуто следующими путями :

Каждый процесс приложения ответвляется от Zygote процесса. Zygote процесс начинает работу при запуске системы и загружает общие ресурсы (например, activity themes). Для того, чтобы новый процесс приложения, система ответвляет Zygote процесс, после чего загружает и запускает код приложения в новом процессе. Это позволяет большей части страничной памяти RAM, выделенной для ресурсов, быть поделённой между всеми процессами.


\section{TCP и UDP протоколы}
TCP и UDP

Протокол UDP (User Datagram Protocol) – протокол транспортного уровня, входящий в стек протоколов TCP/IP, обеспечивающий негарантированную доставку данных без установления виртуального соединения.

Поскольку на протокол не возлагается задач по обеспечению гарантированной доставки, а лишь требуется обеспечивать связь между различными программами, то структура заголовка дейтаграммы UDP (так называется пакет протокола) выглядит достаточно просто – она включает в себя всего четыре поля. Первые два поля содержат номера UDP-портов программы-отправителя и программы-получателя. Два остальных поля в структуре заголовка дейтаграммы предназначены для управления обработкой – это общая длина дейтаграммы и контрольная сумма заголовка.

Протокол TCP (Transmission Control Protocol) является транспортным протоколом стека протоколов TCP/IP, обеспечивающим гарантированную доставку данных с установлением виртуального соединения. 

Протокол предоставляет программам, использующим его, возможность передачи непрерывного потока данных. Данные, подлежащие отправке в сеть, разбиваются на порции, каждая из которых снабжается служебной информацией, то есть формируются пакеты данных. В терминологии TCP пакет называется сегментом.

В соответствии с функциональным назначением протокола структура TCP-сегмента предполагает наличие следующих информационных полей:

\begin{itemize}
\item номер порта-отправителя и номер порта-получателя – номера портов, идентифицирующие программы, между которыми осуществляется взаимодействие;
\item поля, предназначенные для обеспечения гарантированной доставки: размер окна, номер последовательности и номер подтверждения 
\item управляющие флаги – специальные битовые поля, управляющие протоколом. 
\end{itemize}

Реализация режима гарантированной доставки
Для обеспечения гарантированной доставки протокол TCP использует механизм отправки подтверждения. С целью снижения загрузки сети протокол TCP допускает посылку одного подтверждения сразу для нескольких полученных сегментов. Объем данных, которые могут быть переданы в сеть отправителем до получения подтверждения, определяется специальным параметром протокола TCP - размером окна. Размер окна согласуется при установлении соединения между отправителем и получателем и может автоматически изменяться программными модулями протокола TCP в зависимости от состояния канала связи. Если в процессе передачи данных потери происходят достаточно часто, то размер окна уменьшается, и наоборот – окно может иметь большой размер, если высока надежность канала данных. 

Для того, чтобы данные могли быть правильно собраны получателем в нужном порядке, в заголовке TCP-сегмента присутствует информация, определяющая положение вложенных данных в общем потоке. Отправляя подтверждение, получатель указывает положение данных, которые он ожидает получить в следующем сегменте, тем самым косвенно сообщая отправителю, какой фрагмент общего потока был успешно принят. Соответствующие поля заголовка TCP-сегмента получили название номер последовательности и номер подтверждения.

Установление соединения
Перед началом передачи потока данных абоненты должны согласовать параметры передачи: размер окна и начальные номера последовательностей, относительно которых будет отсчитываться положение передаваемых в сегментах данных внутри общего потока. Очевидно, что такое согласование предполагает обмен специальными сегментами и выделение ресурсов, в частности, блоков памяти, необходимых для приема и обработки данных и подтверждений. Соответствующая последовательность действий называется установлением виртуального соединения.

\section{Netty}
Netty - это  non-blocking I/O (NIO)  клиент-серверный фреймворк предназначенный для разработки сетевых приложений на языке Java. Асинхронный событийно-ориентированный фрэймворк используемый для упрощения написания сетевых програм таких как TCP и UDP серверы. В отличии от традиционных Java-реализаций для работы с сетевыми протоколами, использующих синхронную модель передачи данных, Netty позволяет использовать асинхронную передачу, а также службы уровня операционной системы для достижения максимальной скорости передачи данных.

Для своей работы NIO использует:
\begin{itemize}
\item буферы — типы для хранения данных;
\item каналы — аналоги потоков для быстрой записи или чтения данных.
\end{itemize}


\section{Физика???}